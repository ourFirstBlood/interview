## 时间、空间复杂度

### 一、为什么要用复杂度分析

将代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种比我实实在在跑一边来的更准确么？

实际上，上面的方法是可行的，大家还给他名了个漂亮的名字 **事后统计法**

但 `事后统计法` 有缺陷：

- 1. 测试结果非常依赖测试环境
- 2. 测试结果受数据规模的影响很大

所以用到了 `时间、空间复杂度分析`

### 二、大 O 时间复杂度表示法

- 代码执行时间随数据规模增长的变化趋势

```JavaScript
1 function cal(n) {
2    let sum = 0;
3    let i = 1;
4    for(;i<= n;i++) {
5        sum = sum + 1;
6    }
7    return sum;
8 }
```
假设每一行代码执行时间都一样，为unit_time，第2、3行代码分别需要1个 unit_time，第4、5行都运行了 n 遍，需要 2n\*unit_time 的执行时间，所以这段代码的总执行时间为 (2n+2)\*unit_time，所有代码的执行时间 T(n) 与每行代码的执行次数成正比

```
T(n) = O(f(n))
```

T(n) 表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和；O 代表执行时间 T(n) 和 f(n) 表达式成正比。

所以用 大 O 表示法表示刚刚那段代码的时间复杂度为：T(n) = O(n)

#### 1.只关注循环执行次数最多的一段代码

我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了

#### 2.加法法则：总复杂度等于量级最大的那段代码的复杂度

注意点：若循环的次数是固定的100、1000或者10000与n无关，也是属于常量级运算

```javaScript
for(let i=0;i<100;i++) {
    // 时间复杂度为 O(1)
}
```

**T(n) = T1(n) + T2(n) = max(O(f(n)),O(g(n))) = O(max(f(n),g(n)))**

#### 3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

**T(n) =  T1(n) * T2(n) = O(n*n) = O(n^2)**


### 三、几种常见的时间复杂度实例分析

- 常量阶        O(1)
- 对数阶        O(logn)
- 线性阶        O(n)
- 线性对数阶    O(nlogn)
- 平分阶        O(n^2)

![](../images/f1.jpg)

> 对数阶

```javaScript
i = 1;
while (i <= n) {
    i = i * 2;
}
```
从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：

![](../images/f2.jpg)

<p>我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2<sup>x</sup>=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log<sub>2</sub>n，所以，这段代码的时间复杂度就是 O(log<sub>2</sub>n)。<strong>忽略系数</strong>，则最终的时间复杂度为 O(log<sub></sub>n) </p>

### 四、空间复杂度

表示算法的存储空间与数据规模之间的增长关系。

说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。

### 五、最好，最坏时间复杂度

```javaScript
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。

但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。

所以，不同的情况下，这段代码的时间复杂度是不一样的。

为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：**最好情况时间复杂度**、**最坏情况时间复杂度**和**平均情况时间复杂度**。

### 六、平均时间复杂度

以上面为例，要查找的变量 x 在数组中的位置，有 n+1 种情况：<strong>在数组的 0～n-1 位置中</strong>和<strong>不在数组中</strong>。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：

![](../images/f3.jpg)

我们知道，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。

但 n+1 的概率也需要拿出来做判断（概率论的知识）

我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。

![](../images/f4.jpg)

引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。

<p>这个值就是概率论中的<strong>加权平均值</strong>，也叫作<strong>期望值</strong>，所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p>

**只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才需要使用最好、最坏、平均时间复杂度。**

### 总结

- 时间复杂度
  - 循环执行次数最多
  - 循环系数量级最大
  - 循环嵌套最多
- 空间复杂度
  - 存储空间 & 数据规模
- 最好、最坏、平均时间复杂度